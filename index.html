<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Project Baseline V2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* --- 0. 全局变量与基础设定 --- */
    :root {
      --ui-line-color: rgba(154, 210, 255, 0.15);
      --bg-deep: #010204;
      --fg-main: #e8ecf5;
      --fg-soft: #a8b2d1;
      --max-width: 900px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background-color: var(--bg-deep);
      color: var(--fg-main);
      font-family: system-ui, -apple-system, sans-serif;
      overflow-x: hidden;
    }

    /* --- 1. 背景容器 --- */
    .background-container {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      overflow: hidden;
    }
    #bg-canvas, #render-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    /* --- 2. UI 骨架 --- */
    main {
      position: relative;
      z-index: 10;
      width: 100%;
      max-width: var(--max-width);
      margin: 0 auto;
      padding: 0 16px;
    }

    /* --- 3. Hero Section --- */
    .hero-section {
      height: 80vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      margin-bottom: 20vh;
    }
    .hero-title {
      font-size: 3rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }
    .hero-subtitle {
      font-size: 1.1rem;
      color: var(--fg-soft);
      max-width: 600px;
      line-height: 1.7;
    }

    /* --- 4. Content Section & Cards --- */
    .content-section {
      padding: 20vh 0;
      position: relative;
    }
    .content-section::before {
      content: '';
      position: absolute;
      left: 50%;
      top: -20vh;
      bottom: -20vh;
      width: 1px;
      background: linear-gradient(to bottom, transparent, var(--ui-line-color) 20%, var(--ui-line-color) 80%, transparent);
      transform: translateX(-50%);
    }

    .cs-card {
      display: grid;
      grid-template-columns: 1.5fr 1fr;
      gap: 48px;
      align-items: start; /* Align to top by default */
    }
    .cs-card.reverse {
      grid-template-columns: 1fr 1.5fr;
    }
    .cs-card.reverse .cs-text {
      grid-column: 1;
      grid-row: 1;
    }

    .cs-text {
      padding: 16px;
      text-align: left;
      transition: all 0.5s ease-in-out;
    }
    .cs-card.reverse .cs-text {
      text-align: right;
    }

    .cs-title { font-size: 24px; margin-bottom: 16px; }
    .cs-summary { color: var(--fg-soft); line-height: 1.7; }
    
    /* --- Card Expansion Logic --- */
    .cs-details {
      max-height: 0;
      overflow: hidden;
      color: var(--fg-soft);
      line-height: 1.7;
      transition: max-height 0.7s ease-in-out, margin-top 0.7s ease-in-out;
    }
    /* When expanded, the text column now spans the full width */
    .cs-card.is-expanded {
      grid-template-columns: 1fr;
      /* The visual is vertically centered when the card is expanded */
      align-items: center;
    }
    .cs-card.is-expanded .cs-text {
      text-align: left; /* Force left-align on expand for readability */
    }
    .cs-card.is-expanded .cs-details {
      max-height: 500px; /* A large enough value to not clip the content */
      margin-top: 16px;
    }
    /* The visual element is placed in the second row when expanded, below the text. */
    .cs-card.is-expanded .cs-visual {
      grid-row: 2;
      margin-top: 32px;
    }
    .cs-card.is-expanded.reverse .cs-visual {
      grid-column: 1;
    }

    .cs-expand-toggle {
      background: none;
      border: 1px solid var(--ui-line-color);
      color: var(--fg-soft);
      padding: 8px 16px;
      margin-top: 24px;
      cursor: pointer;
      transition: background-color 0.3s, color 0.3s;
    }
    .cs-expand-toggle:hover {
      background-color: var(--ui-line-color);
      color: var(--fg-main);
    }
    .cs-card.is-expanded .cs-expand-toggle {
      background-color: var(--ui-line-color);
    }

    .cs-visual {
      aspect-ratio: 16/10;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #5c667e;
      overflow: hidden;
      transition: all 0.5s ease-in-out;
    }
    .cs-visual img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
  </style>
</head>
<body>

  <div class="background-container">
    <canvas id="bg-canvas"></canvas>
    <canvas id="render-canvas"></canvas>
  </div>

  <main>
    <section class="hero-section">
      <div class="hero-content">
        <h1 class="hero-title">Your Name / Title</h1>
        <p class="hero-subtitle">My work explores the intersection of aesthetics and logic, manifesting 'possibility' through the mediums of games and visual arts.</p>
      </div>
    </section>

    <section class="content-section" data-color="50, 80, 220">
      <div class="cs-card">
        <div class="cs-visual">
          <img src="Assets\Cel-shading.png" alt="Cel-shading solution visual">
        </div>
        <div class="cs-text">
          <h2 class="cs-title">Core Solution 01: Performant Cel-Shading</h2>
          <div class="cs-summary">
            <p>Deferred rendering is efficient but its photorealistic nature clashes with stylized cel-shading. This solution bridges that gap.</p>
          </div>
          <div class="cs-details">
            <p>My shader fully integrates with the deferred rendering pipeline and post-processing stack, achieving a look that is performant, realistic, and stylized—all at the same time. Features include smooth outlines, adaptive detail normals, MatCap-inspired hair, and fully customizable rim lighting and masks.</p>
          </div>
          <button class="cs-expand-toggle">Expand</button>
        </div>
      </div>
    </section>

    <section class="content-section" data-color="110, 50, 90">
      <div class="cs-card reverse">
        <div class="cs-text">
          <h2 class="cs-title">Core Solution 02: Per-Object Shadowing</h2>
          <div class="cs-summary">
            <p>Real-time shadows are a performance bottleneck. Per-object shadowing decouples shadow cost from scene complexity, tying it directly to shadow-casting objects.</p>
          </div>
          <div class="cs-details">
            <p>This allows for fully baked scene lighting while retaining high-definition, controllable dynamic shadows, ideal for top-down or indoor scenarios where only a few characters need dynamic shadows.</p>
          </div>
          <button class="cs-expand-toggle">Expand</button>
        </div>
        <div class="cs-visual">
          <img src="Assets\Per-objectShadow.png" alt="Per-object shadow visual">
        </div>
      </div>
    </section>

    <div class="placeholder-section" style="height: 100vh; display: flex; align-items: center; justify-content: center; color: #5c667e;">TECH GALLERY (Placeholder)</div>
    <div class="placeholder-section" style="height: 100vh; display: flex; align-items: center; justify-content: center; color: #5c667e;">MY GAMES (Placeholder)</div>
    <div class="placeholder-section" style="height: 100vh; display: flex; align-items: center; justify-content: center; color: #5c667e;">ABOUT & SKILLS (Placeholder)</div>

  </main>

  <script>
    // =======================================================================
    //  SECTION 0: MASTER INITIALIZATION & CONFIG
    // =======================================================================
    const fgCanvas = document.getElementById('render-canvas');
    const fgCtx = fgCanvas.getContext('2d');
    const bgCanvas = document.getElementById('bg-canvas');
    const gl = bgCanvas.getContext('webgl', { antialias: true, powerPreference: "high-performance", alpha: false });

    if (!gl) {
      console.error("CRITICAL: WebGL is not supported. The background will not render.");
      bgCanvas.style.display = 'none';
    }

    let width, height;
    let scrollY = window.scrollY;

    const STAR_COUNT = 40;
    const GRID_SPACING = 120;
    const GRID_DIMENSIONS = 40;
    const GRID_DEPTH_SEGMENTS = GRID_DIMENSIONS / 2;
    const NODE_SIZE = 3.5;

    // =======================================================================
    //  SECTION 1: FOREGROUND (2D CANVAS: STARS & GRID) - YOUR VERSION
    // =======================================================================
    const stars = [];
    const gridPoints = [];
    const camera = {
      fov: 355,
      y: 0,
      rotationX: 0,
      targetY: 0,
      targetRotationX: 0,
      lerpFactor: 0.07
    };

    function project(p) {
      const cosX = Math.cos(camera.rotationX);
      const sinX = Math.sin(camera.rotationX);
      const translatedY = p.y - camera.y;
      const rotatedY = 41 * translatedY * cosX - 0.1 * p.z * sinX;
      const rotatedZ = 0 * translatedY * sinX + p.z * cosX;

      if (rotatedZ <= 0) return null;

      const scale = camera.fov / rotatedZ;
      return {
        x: width / 2 + p.x * scale,
        y: height / 2 - rotatedY * scale,
        scale: scale,
        z: rotatedZ
      };
    }

    function drawForeground() {
      fgCtx.clearRect(0, 0, width, height);

      fgCtx.fillStyle = '#dce2f0';
      stars.forEach(star => {
        const y = (star.y - scrollY * star.depth + height);
        fgCtx.beginPath();
        fgCtx.arc(star.x, y, star.size, 0, 2 * Math.PI);
        fgCtx.fill();
      });

      const projectedPoints = gridPoints.map(project);
      const gridWidth = GRID_DIMENSIONS * 2 + 1;
      fgCtx.strokeStyle = 'rgba(80, 130, 255, 0.2)';
      fgCtx.lineWidth = 1;

      for (let i = 0; i < gridWidth; i++) {
        for (let j = 0; j <= GRID_DEPTH_SEGMENTS; j++) {
          const currentIdx = i * (GRID_DEPTH_SEGMENTS + 1) + j;
          const p_current = projectedPoints[currentIdx];
          if (!p_current || p_current.y < 0) continue;
          if (j > 0) {
            const p_behind = projectedPoints[currentIdx - 1];
            if (p_behind && p_behind.y > 0) {
              fgCtx.beginPath();
              fgCtx.moveTo(p_current.x, p_current.y);
              fgCtx.lineTo(p_behind.x, p_behind.y);
              fgCtx.stroke();
            }
          }
          if (i > 0) {
            const p_side = projectedPoints[currentIdx - (GRID_DEPTH_SEGMENTS + 1)];
            if (p_side && p_side.y > 0) {
              fgCtx.beginPath();
              fgCtx.moveTo(p_current.x, p_current.y);
              fgCtx.lineTo(p_side.x, p_side.y);
              fgCtx.stroke();
            }
          }
        }
      }

      projectedPoints.forEach(p => {
        if (p && p.y > 0) {
          const size = NODE_SIZE * Math.min(p.scale, 1.0);
          const alpha = 1 - Math.min(p.z / 8000, 1);
          if (alpha > 0.01) {
            fgCtx.globalAlpha = alpha;
            fgCtx.shadowBlur = size * 4;
            fgCtx.shadowColor = 'rgba(80, 130, 255, 0.5)';
            fgCtx.fillStyle = 'rgba(80, 130, 255, 0.8)';
            fgCtx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
          }
        }
      });
      fgCtx.globalAlpha = 1;
      fgCtx.shadowBlur = 0;
    }

    // =======================================================================
    //  SECTION 2: BACKGROUND (WEBGL CANVAS: PROCEDURAL NEBULA)
    // =======================================================================
    const vertexShaderSource = `
      attribute vec2 a_position; void main() { gl_Position = vec4(a_position, 0.0, 1.0); }`;
    const fragmentShaderSource = `
      precision highp float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec3 u_color;
      uniform sampler2D u_blueNoise;
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
      float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy)); vec2 x0 = v - i + dot(i, C.xx);
        vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1;
        i = mod289(i);
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m; m = m*m;
        vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5); vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
        vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }
      float fbm(vec2 st) {
        st *= 0.1; st += 0.1; float value = 0.0; float amplitude = 0.5;
        for (int i = 0; i < 6; i++) { value += amplitude * snoise(st); st *= 2.0; amplitude *= 0.5; }
        return value;
      }
      void main() {
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        st.x *= u_resolution.x / u_resolution.y;
        float t = u_time * 0.08;
        vec2 q = vec2(fbm(st + vec2(t*0.2, t*0.1)), fbm(st + vec2(-t*0.15, t*0.25)));
        vec2 r = vec2(fbm(st + q*2.0 + vec2(t*-0.3, t*0.05)), fbm(st + q*2.0 + vec2(t*0.1, -t*0.3)));
        float value = fbm(st + r*0.5);
        float contrastValue = pow(max(0.0, value), 2.2);
        vec3 finalColor = u_color * contrastValue * 1.5;
        vec3 noise = texture2D(u_blueNoise, gl_FragCoord.xy / 256.0).rgb;
        finalColor += (noise - 0.5) / 128.0;
        gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), 1.0);
      }`;

    let glProgram, positionAttributeLocation, resolutionUniformLocation, timeUniformLocation, colorUniformLocation, blueNoiseUniformLocation;
    let currentR = 50, currentG = 80, currentB = 220;
    let targetR = 50, targetG = 80, targetB = 220;
    let blueNoiseTexture;

    function loadTexture(gl, url) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      };
      image.src = url;
      return texture;
    }

    function setupWebGL() {
      if (!gl) return;
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      glProgram = createProgram(gl, vertexShader, fragmentShader);
      positionAttributeLocation = gl.getAttribLocation(glProgram, "a_position");
      resolutionUniformLocation = gl.getUniformLocation(glProgram, "u_resolution");
      timeUniformLocation = gl.getUniformLocation(glProgram, "u_time");
      colorUniformLocation = gl.getUniformLocation(glProgram, "u_color");
      blueNoiseUniformLocation = gl.getUniformLocation(glProgram, "u_blueNoise");
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
      gl.useProgram(glProgram);
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
      blueNoiseTexture = loadTexture(gl, 'assets/blueNoise.png');
    }

    function renderBackground(time) {
      if (!gl) return;
      time *= 0.001;
      currentR += (targetR - currentR) * 0.02;
      currentG += (targetG - currentG) * 0.02;
      currentB += (targetB - currentB) * 0.02;
      gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
      gl.uniform1f(timeUniformLocation, time);
      gl.uniform3f(colorUniformLocation, currentR / 255, currentG / 255, currentB / 255);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, blueNoiseTexture);
      gl.uniform1i(blueNoiseUniformLocation, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    // =======================================================================
    //  SECTION 3: MASTER CONTROL & EVENT LISTENERS
    // =======================================================================
    function masterInit() {
      width = window.innerWidth;
      height = window.innerHeight;
      fgCanvas.width = width;
      fgCanvas.height = height;
      if (gl) {
        bgCanvas.width = width;
        bgCanvas.height = height;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      }
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: (0.15 + 0.7 * Math.random()) * width,
          y: (1.2 * Math.random() - 0.8) * height,
          depth: Math.random() * 0.4 + 0.1,
          size: Math.random() * 1.2 + 0.5
        });
      }
      gridPoints.length = 0;
      for (let i = -GRID_DIMENSIONS; i <= GRID_DIMENSIONS; i++) {
        for (let j = 0; j <= GRID_DEPTH_SEGMENTS; j++) {
          gridPoints.push({ x: i * GRID_SPACING, y: 0, z: j * 1.5 * GRID_SPACING });
        }
      }
    }

    function masterAnimate(time) {
      scrollY = window.scrollY;
      const scrollHeight = document.body.scrollHeight - window.innerHeight;
      const scrollRatio = scrollHeight > 0 ? scrollY / scrollHeight : 0;
      
      // YOUR CAMERA LOGIC - PRESERVED
      const targetY = 1200 * (0 + 0.01 * (1 - scrollRatio));
      const targetRotationX = (0.5 * (-6 + 6 * scrollRatio)) * Math.PI / 180 + 1.48;
      camera.y += (targetY - camera.y) * camera.lerpFactor;
      camera.rotationX += (targetRotationX - camera.rotationX) * camera.lerpFactor;

      if (gl) renderBackground(time);
      drawForeground();
      requestAnimationFrame(masterAnimate);
    }

    // --- FIX: Intersection Observer for color changes ---
    const sections = document.querySelectorAll('.content-section[data-color]');
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const [r, g, b] = entry.target.dataset.color.split(',').map(Number);
          targetR = r;
          targetG = g;
          targetB = b;
        }
      });
    }, { threshold: 0.5 });
    sections.forEach(section => observer.observe(section));

    // --- NEW: Event Listeners for Card Expansion ---
    document.querySelectorAll('.cs-expand-toggle').forEach(button => {
      button.addEventListener('click', () => {
        const card = button.closest('.cs-card');
        card.classList.toggle('is-expanded');
        button.textContent = card.classList.contains('is-expanded') ? 'Collapse' : 'Expand';
      });
    });

    // --- Start Everything ---
    window.addEventListener('resize', masterInit);
    
    createShader = function(gl, type, source) {
      const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error("Error compiling shader:", gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; }
      return shader;
    }
    createProgram = function(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram(); gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error("Error linking program:", gl.getProgramInfoLog(program)); gl.deleteProgram(program); return null; }
      return program;
    }

    setupWebGL();
    masterInit();
    masterAnimate();
  </script>
</body>
</html>