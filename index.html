<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Portfolio – Technical Art & Real-Time Rendering</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg-deep: #010204;
      --fg-main: #e8ecf5;
      --fg-soft: #a8b2d1;
      --fg-muted: #6b7184;

      --accent-aurora-1: #6be6ff;
      --accent-aurora-2: #52ffb8;
      --accent-aurora-3: #8a7aff;

      --line-soft: rgba(140, 200, 255, 0.18);
      --line-strong: rgba(140, 200, 255, 0.45);

      --content-padding-x: clamp(16px, 5vw, 64px);
      --section-gap: 26vh;

      --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background-color: var(--bg-deep);
      color: var(--fg-main);
      font-family: var(--font-sans);
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
    }

    a {
      color: inherit;
      text-decoration: none;
    }

    .background-container {
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      overflow: hidden;
    }

    #bg-canvas,
    #render-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .bg-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at top center,
          rgba(0, 10, 35, 0.8) 0,
          rgba(0, 0, 0, 0.0) 55%),
        radial-gradient(circle at bottom center,
          rgba(0, 0, 0, 0.7) 0,
          transparent 60%);
      mix-blend-mode: soft-light;
      z-index: -1;
    }

    main {
      width: 100%;
      padding: 0 var(--content-padding-x);
    }

    section {
      position: relative;
    }

    /* ================= HERO (full-width band) ================= */

    .hero-shell {
      position: relative;
      padding: 56px 20px;
      /* 在这里局部覆盖一些颜色；只影响 hero 区域 */
      --hero-title-gradient: linear-gradient(120deg, var(--accent-aurora-1), var(--accent-aurora-2));
      --hero-strike-color: rgba(140, 200, 255, 0.8);
      --hero-text-main: var(--fg-main);
      --hero-text-soft: var(--fg-soft);
      --hero-text-muted: var(--fg-muted);
    }

    /* 媒体带容器：横贯全屏，控制比例 */
    .hero-media {
      position: relative;
      width: 100%;
      border-radius: 24px;
      overflow: hidden;
      /* 用 aspect-ratio 控制大致 16:7，比 16:9 更扁一点 */
      aspect-ratio: 16 / 7;
      max-height: 60vh;
      background: radial-gradient(circle at 20% 10%, #274986 0, #040611 55%);
      box-shadow:
        0 40px 120px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    .hero-media img,
    .hero-media video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* 可选：给视频一个轻微的色彩调整，保持跟整站一致的调性 */
    .hero-media video {
      filter: saturate(1.05) contrast(1.03) brightness(0.97);
    }

    /* 媒体上的 aurora 光+暗角+向下渐隐到背景 */
    .hero-media::before {
      content: '';
      position: absolute;
      inset: -20%;
      background:
        radial-gradient(circle at 20% 10%, rgba(107, 230, 255, 0.6), transparent 48%),
        radial-gradient(circle at 80% 70%, rgba(138, 122, 255, 0.55), transparent 52%),
        linear-gradient(to bottom, rgba(0, 0, 0, 0.45), rgba(0, 0, 0, 0.9));
      mix-blend-mode: screen;
      pointer-events: none;
      opacity: 0.9;
    }

    /* 下缘渐变到页面主背景 + 轻微纹理感 */
    .hero-media::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      height: 40%;
      background:
        /* 垂直渐变：从透明过渡到 bg-deep */
        linear-gradient(to bottom,
          rgba(1, 2, 4, 0.0) 0%,
          rgba(1, 2, 4, 0.35) 45%,
          rgba(1, 2, 4, 0.82) 100%);
      pointer-events: none;
      /* 简易 noise 纹理：用小尺寸背景图将来可替代；当前先用渐变的“条纹”感占位 */
      background-blend-mode: soft-light;
    }

    /* 文案块：略微 overlap 到 hero-media，下方继续延伸到页面背景 */
    .hero-content {
      position: relative;
      margin: 0 auto;
      padding-top: 32px;
      /* 负 margin 把文字稍微拉到图片区域内，形成“嵌入侵入感” */
      margin-top: -92px;
      padding-inline: var(--content-padding-x);
      /* 为了确保文字仍然清晰可读，加一点顶部内边距 */
    }

    /* 大屏时居左，窄屏时还是左对齐但 margin 自动适配 */
    @media (min-width: 960px) {
      .hero-content {
        margin-left: 0;
      }
    }

    .hero-tagline {
      position: relative;
      font-size: 11px;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: var(--hero-text-muted);
      margin-bottom: 16px;
      padding-left: 26px;
      /* 为左侧小 dash 留出空间 */
    }

    .hero-title {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-weight: 650;
      letter-spacing: 0.02em;
      line-height: 1.1;
      margin-bottom: 14px;
    }


    .hero-tagline::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      width: 20px;
      height: 1px;
      transform: translateY(-50%);
      background: linear-gradient(to right,
          rgba(107, 230, 255, 0.0),
          rgba(107, 230, 255, 0.85));
      opacity: 0.9;
    }

    .hero-title-name {
      font-size: clamp(1.8rem, 2.8vw, 2.3rem);
      color: var(--hero-text-main);
      margin-bottom: 10px;
    }

    .hero-title-highlight {
      font-size: clamp(1.2rem, 2.2vw, 1.4rem);
      max-width: 32ch;
      /* 别让这句无限拉长 */
      background: var(--hero-title-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 1 1 20px rgba(0, 0, 0, 0.85);
    }

    .hero-subline {
      font-size: 14px;
      color: var(--hero-text-soft);
      line-height: 1.8;
      max-width: 60ch;
      margin-bottom: 8px;
      /* 稍微缩小一点，避免两段隔太开 */
    }

    /* 第一段气质句，稍微淡一点强调 */
    .hero-subline-lead {
      font-weight: 500;
      color: var(--hero-text-main);
    }

    /* 炫光 strike：短横线，带一点渐变发光但不过分 */
    .hero-strike {
      width: 88px;
      height: 1px;
      border-radius: 999px;
      background:
        linear-gradient(to right,
          rgba(140, 200, 255, 0.0),
          rgba(115, 215, 255, 0.9),
          rgba(140, 200, 255, 0.0));
      /* 去掉 box-shadow，避免变成光斑 */
      box-shadow: none;
      margin-bottom: 14px;
      opacity: 0.9;
    }

    .hero-meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--hero-text-muted);
    }

    .hero-meta-pill {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(140, 200, 255, 0.25);
      background: radial-gradient(circle at top left,
          rgba(140, 200, 255, 0.16),
          rgba(3, 6, 16, 0.88));
      backdrop-filter: blur(10px);
    }

    /* 响应式调整：窄屏时减小高度和 overlap，避免图片过高/文字拥挤 */
    @media (max-width: 960px) {
      .hero-shell {
        padding-top: 40px;
        padding-bottom: 32px;
      }

      .hero-media {
        aspect-ratio: 16 / 9;
        max-height: 40vh;
        border-radius: 20px;
      }

      .hero-content {
        margin-top: -40px;
        padding-top: 24px;
        max-width: 100%;
      }

      .hero-subline {
        max-width: none;
      }
    }

    @media (max-width: 600px) {
      .hero-shell {
        padding: 32px var(--content-padding-x) 28px;
      }

      .hero-title-name {
        font-size: 1.6rem;
      }

      .hero-title-highlight {
        font-size: 1.9rem;
      }

      .hero-subline {
        font-size: 13px;
      }

      .hero-strike {
        width: 64px;
      }
    }

    /* ============ Section frame ============ */

    .content-section {
      padding: var(--section-gap) 0;
      position: relative;
    }

    .content-section::before {
      content: '';
      position: absolute;
      left: 50%;
      top: -30px;
      height: var(--section-gap);
      width: 1px;
      background: linear-gradient(to bottom,
          rgba(135, 190, 255, 0.0),
          var(--line-soft) 50%,
          rgba(135, 190, 255, 0.0));
      transform: translateX(-50%);
    }

    .section-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 32px;
    }

    .section-kicker {
      font-size: 11px;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: var(--fg-muted);
    }

    .section-title {
      font-size: 18px;
      font-weight: 500;
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .section-subtitle {
      font-size: 13px;
      color: var(--fg-soft);
      max-width: 46ch;
      line-height: 1.7;
      text-align: right;
    }

    @media (max-width: 820px) {
      .section-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .section-subtitle {
        text-align: left;
      }
    }

    /* ============ Cards (Core + Games) ============ */

    .cs-card {
      display: grid;
      grid-template-columns: minmax(0, 1.6fr) minmax(40px, 5vw) minmax(0, 1.3fr);
      align-items: center;
      position: relative;
      padding: 28px 0;
    }

    .cs-card+.cs-card {
      border-top: 1px solid rgba(120, 150, 200, 0.2);
    }

    .cs-card.reverse {
      grid-template-columns: minmax(0, 1.3fr) minmax(40px, 5vw) minmax(0, 1.6fr);
    }

    .cs-card::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 1px;
      background: linear-gradient(to right,
          transparent,
          rgba(140, 200, 255, 0.65),
          transparent);
      transform: translate(-50%, -50%);
      opacity: 0.9;
    }

    .cs-visual {
      grid-column: 1 / 2;
      border-radius: 18px;
      overflow: hidden;
      position: relative;
      box-shadow:
        0 24px 70px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.05);
      transition: transform 0.35s ease, box-shadow 0.35s ease;
    }

    .cs-card.reverse .cs-visual {
      grid-column: 3 / 4;
    }

    .cs-visual img {
      display: block;
      width: 100%;
      height: auto;
    }

    .cs-visual::after {
      content: '';
      position: absolute;
      top: 50%;
      right: -8px;
      width: 12px;
      height: 36px;
      border-radius: 999px;
      background: radial-gradient(circle at center,
          rgba(120, 210, 255, 0.9),
          rgba(120, 210, 255, 0.0) 65%);
      opacity: 0.6;
      pointer-events: none;
    }

    .cs-card.reverse .cs-visual::after {
      right: auto;
      left: -8px;
    }

    .cs-card:hover .cs-visual {
      transform: translateY(-6px);
      box-shadow:
        0 30px 90px rgba(0, 0, 0, 0.95),
        0 0 0 1px rgba(180, 230, 255, 0.22);
    }

    .cs-text {
      grid-column: 3 / 4;
      position: relative;
      padding: 12px 0 12px 26px;
      cursor: pointer;
    }

    .cs-card.reverse .cs-text {
      grid-column: 1 / 2;
      padding: 12px 26px 12px 0;
      text-align: right;
      cursor: pointer;
    }

    .cs-eyebrow {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--fg-muted);
      margin-bottom: 8px;
    }

    .cs-title {
      font-size: 20px;
      font-weight: 560;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .cs-title-badge {
      font-size: 10px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(140, 200, 255, 0.35);
      color: var(--fg-soft);
    }

    .cs-meta-line {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--fg-muted);
      margin-bottom: 10px;
    }

    .cs-summary {
      font-size: 13px;
      color: var(--fg-soft);
      line-height: 1.9;
      max-width: 40ch;
    }

    .cs-card.reverse .cs-summary {
      margin-left: auto;
    }

    .cs-text::after {
      content: '';
      position: absolute;
      left: 26px;
      right: 0;
      bottom: 0;
      height: 1px;
      background: linear-gradient(to right,
          transparent,
          var(--line-soft),
          transparent);
      transform: scaleX(0.0);
      transform-origin: left;
      transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1),
        opacity 0.4s ease;
      opacity: 0;
    }

    .cs-card.reverse .cs-text::after {
      left: 0;
      right: 26px;
      transform-origin: right;
    }

    .cs-card:hover .cs-text::after {
      opacity: 1;
      transform: scaleX(1);
    }

    .cs-card.is-expanded .cs-text::after {
      opacity: 1;
      transform: scaleX(1);
      background: linear-gradient(to right,
          transparent,
          var(--line-strong),
          transparent);
    }

    .cs-details {
      max-height: 0;
      overflow: hidden;
      color: var(--fg-soft);
      line-height: 1.8;
      font-size: 13px;
      transition: max-height 0.7s ease, margin-top 0.7s ease;
    }

    .cs-card.is-expanded .cs-details {
      max-height: 1200px;
      margin-top: 18px;
    }

    .cs-detail-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 20px;
      margin-top: 10px;
    }

    .cs-detail-block-title {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--fg-muted);
      margin-bottom: 6px;
    }

    .cs-detail-block ul {
      list-style: none;
      padding: 0;
    }

    .cs-detail-block li {
      margin-bottom: 4px;
    }

    .cs-detail-block li::before {
      content: '– ';
      color: var(--accent-aurora-1);
    }

    .cs-detail-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .cs-detail-gallery img {
      width: 100%;
      display: block;
      border-radius: 8px;
      opacity: 0.86;
      transition: opacity 0.25s ease, transform 0.25s ease;
    }

    .cs-detail-gallery img:hover {
      opacity: 1;
      transform: translateY(-2px);
    }

    .game-tag {
      color: var(--accent-aurora-2);
    }

    @media (max-width: 860px) {

      .cs-card,
      .cs-card.reverse {
        grid-template-columns: 1fr;
        padding: 24px 0;
      }

      .cs-visual,
      .cs-card.reverse .cs-visual {
        grid-column: 1 / -1;
        margin-bottom: 18px;
      }

      .cs-text,
      .cs-card.reverse .cs-text {
        grid-column: 1 / -1;
        padding: 8px 0;
        text-align: left;
      }

      .cs-summary {
        max-width: none;
      }

      .cs-text::after,
      .cs-card.reverse .cs-text::after {
        left: 0;
        right: 0;
        transform-origin: center;
      }
    }

    /* ============ About & Skills ============ */

    .about-layout {
      display: grid;
      grid-template-columns: minmax(0, 1.3fr) minmax(0, 1.4fr);
      gap: 32px;
      align-items: flex-start;
    }

    .about-text {
      font-size: 14px;
      line-height: 1.9;
      color: var(--fg-soft);
    }

    .skills-matrix {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 18px 32px;
      font-size: 13px;
      color: var(--fg-soft);
    }

    .skills-group h3 {
      font-size: 11px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--fg-muted);
      margin-bottom: 6px;
    }

    .skills-group p {
      line-height: 1.7;
    }

    @media (max-width: 860px) {
      .about-layout {
        grid-template-columns: 1fr;
      }

      .skills-matrix {
        grid-template-columns: 1fr;
      }
    }

    /* ============ Contact & Horizon ============ */

    .contact-block {
      font-size: 13px;
      color: var(--fg-soft);
      line-height: 1.8;
    }

    .contact-list {
      list-style: none;
      margin-top: 10px;
    }

    .contact-list li+li {
      margin-top: 6px;
    }

    .contact-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--fg-muted);
      margin-right: 8px;
    }

    .horizon-wrap {
      margin-top: 72px;
      padding-bottom: 40px;
      text-align: center;
    }

    .horizon-line {
      position: relative;
      height: 1px;
      background: linear-gradient(to right,
          rgba(70, 90, 130, 0.0),
          rgba(120, 160, 220, 0.7),
          rgba(70, 90, 130, 0.0));
      margin-bottom: 18px;
    }

    .horizon-orbit {
      position: absolute;
      left: 50%;
      top: -14px;
      width: 32px;
      height: 32px;
      transform: translateX(-50%);
      border-radius: 50%;
      border: 1px solid rgba(140, 200, 255, 0.6);
      box-shadow: 0 0 18px rgba(140, 200, 255, 0.5);
    }

    .horizon-orbit::before {
      content: '';
      position: absolute;
      inset: 6px;
      border-radius: 50%;
      border: 1px dashed rgba(140, 200, 255, 0.4);
    }

    .horizon-orbit::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 50%;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      transform: translateX(-50%);
      background: radial-gradient(circle, #ffffff, #7ee4ff);
      box-shadow: 0 0 10px rgba(126, 228, 255, 0.9);
    }

    .horizon-caption {
      font-size: 12px;
      color: var(--fg-muted);
      letter-spacing: 0.14em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .horizon-phrase {
      font-size: 13px;
      color: var(--fg-soft);
    }
  </style>
</head>

<body>

  <div class="background-container">
    <canvas id="bg-canvas"></canvas>
    <canvas id="render-canvas"></canvas>
  </div>
  <div class="bg-overlay"></div>

  <main>
    <!-- ============ HERO ============ -->
    <section class="hero-shell">
      <!-- 媒体带：后续可替换为序列帧 / video / canvas -->
      <div class="hero-media">
        <video class="hero-video" src="Assets/hero-banner.mp4" autoplay muted loop playsinline
          poster="Assets/hero-banner.png"></video>
      </div>

      <!-- 文案内容层 -->
      <div class="hero-content">
        <div class="hero-tagline">TECHNICAL ART · REAL-TIME RENDERING · PIPELINES</div>

        <h1 class="hero-title">
          <span class="hero-title-name">Your Name</span>
          <div class="hero-strike"></div>
          <!--
          <span class="hero-title-highlight">
            My work lives on the boundary between aesthetics and logic.
          </span>
        -->
        </h1>


        <p class="hero-subline hero-subline-lead">
          My work lives on the boundary between aesthetics and logic.
        </p>
        <p class="hero-subline">
          I build real-time visuals and systems for games and interactive work – from shaders and lighting to production
          tools.
        </p>
        <!--
        <div class="hero-meta-row">
          <div class="hero-meta-pill">Rendering & Shading</div>
          <div class="hero-meta-pill">Pipelines & Tools</div>
          <div class="hero-meta-pill">PC & Mobile</div>
        </div>
        -->
      </div>
    </section>

    <!-- ============ CORE SOLUTIONS ============ -->
    <section class="content-section" data-color="80, 220, 180">
      <header class="section-header">
        <div>
          <div class="section-kicker">CORE SOLUTIONS</div>
          <div class="section-title">Rendering Systems</div>
        </div>
        <p class="section-subtitle">
          A sample of the kind of systems I like to build: practical, stylized, and designed to live inside real
          production pipelines.
        </p>
      </header>

      <!-- Core 01 -->
      <div class="cs-card">
        <div class="cs-visual">
          <img src="Assets/Cel-shading.png" alt="Stylized character shading in a lit scene">
        </div>
        <div class="cs-text">
          <div class="cs-eyebrow">CORE 01 · SHADING</div>
          <h2 class="cs-title">
            NPR Shading in Deferred Scenes
            <span class="cs-title-badge">URP</span>
          </h2>
          <div class="cs-meta-line">Stylized characters · busy environments · one lighting setup</div>
          <div class="cs-summary">
            <p>
              The goal here is simple: let strongly stylized characters sit inside complex, deferred-lit scenes
              without special-case compositing tricks. Characters, props, and environments share the same lights
              and depth, while art still gets the controls it needs.
            </p>
          </div>
          <div class="cs-details">
            <div class="cs-detail-grid">
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">What It Does</div>
                <ul>
                  <li>Uses an NPR shading path that works inside a deferred-style setup and still writes sane depth and
                    lighting.</li>
                  <li>Keeps stylized characters playing nicely with depth-based effects in the existing pipeline.</li>
                  <li>Respects how scenes are already lit, instead of forcing a separate “toon-only” world.</li>
                </ul>
              </div>
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">Look Controls</div>
                <ul>
                  <li>Geometry-based outlines that stay smooth with camera movement and resolution changes.</li>
                  <li>Adaptive normal detail: close-up materials keep their texture; distance shots stay clean.</li>
                  <li>Dedicated controls for stylized highlights and rim light on hair and key materials.</li>
                </ul>
              </div>
            </div>
            <div class="cs-detail-gallery">
              <img src="Assets/cel-1.jpg" alt="Character lighting close-up">
              <img src="Assets/cel-2.jpg" alt="Material and stockings detail">
              <img src="Assets/cel-3.jpg" alt="Hair shading from different angles">
              <img src="Assets/cel-4.jpg" alt="Rim-lit cinematic frame">
            </div>
          </div>
        </div>
      </div>

      <!-- Core 02 -->
      <div class="cs-card reverse">
        <div class="cs-text">
          <div class="cs-eyebrow">CORE 02 · LIGHT & SHADOW</div>
          <h2 class="cs-title">
            Per-Object Shadows for Baked Worlds
            <span class="cs-title-badge">URP</span>
          </h2>
          <div class="cs-meta-line">Fully baked scenes · dynamic characters · predictable cost</div>
          <div class="cs-summary">
            <p>
              In top-down and indoor scenes, turning on full real-time shadows for a handful of moving characters
              is often the biggest performance sink. This setup keeps the world baked and gives only the important
              dynamic objects their own high-quality, adjustable shadows.
            </p>
          </div>
          <div class="cs-details">
            <div class="cs-detail-grid">
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">What It Does</div>
                <ul>
                  <li>Keeps static lighting fully baked so the environment doesn’t pay for real-time shadows.</li>
                  <li>Lets characters and key props project their own shadows onto the baked world.</li>
                  <li>Makes shadow cost scale with “how many things actually need it” instead of scene size.</li>
                </ul>
              </div>
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">Art Controls</div>
                <ul>
                  <li>Per-object control over softness, density, and length.</li>
                  <li>Editable directly in-scene, so artists can dial shadows while looking at the shot.</li>
                  <li>Visually designed to sit next to baked lightmaps and AO without fighting them.</li>
                </ul>
              </div>
            </div>
            <div class="cs-detail-gallery">
              <img src="Assets/shadow-1.jpg" alt="Top-down baked scene with dynamic characters">
              <img src="Assets/shadow-2.jpg" alt="Shadow parameters adjusted in editor">
              <img src="Assets/shadow-3.jpg" alt="Character shadow close-up">
            </div>
          </div>
        </div>
        <div class="cs-visual">
          <img src="Assets/Per-objectShadow.png" alt="Per-object shadow visual">
        </div>
      </div>
    </section>

    <!-- ============ TECH GALLERY ============ -->
    <section class="content-section" data-color="110, 140, 255">
      <header class="section-header">
        <div>
          <div class="section-kicker">TECH GALLERY</div>
          <div class="section-title">Systems, Shaders & Tools</div>
        </div>
        <p class="section-subtitle">
          A cross-section of smaller rendering pieces and utilities I’ve built along the way.
        </p>
      </header>

      <!-- 这里可以用简化版卡片结构，先放几个例子 -->

      <div class="cs-card">
        <div class="cs-visual">
          <img src="Assets/skybox.jpg" alt="Dynamic skybox and lighting">
        </div>
        <div class="cs-text">
          <div class="cs-eyebrow">TECH 01 · SKY & LIGHT</div>
          <h2 class="cs-title">
            Layered Skybox & Time-of-Day
            <span class="cs-title-badge">URP</span>
          </h2>
          <div class="cs-meta-line">Custom skybox · time-driven lighting hooks</div>
          <div class="cs-summary">
            <p>
              A multi-layer skybox shader wired into a time controller, used to drive lighting mood and subtle
              color shifts across a scene without going into full volumetric simulation.
            </p>
          </div>
        </div>
      </div>

      <div class="cs-card reverse">
        <div class="cs-text">
          <div class="cs-eyebrow">TECH 02 · MATERIALS</div>
          <h2 class="cs-title">
            Triplanar Material Pipeline
            <span class="cs-title-badge">URP</span>
          </h2>
          <div class="cs-meta-line">World-space texturing · no-UV geometry</div>
          <div class="cs-summary">
            <p>
              A hand-written triplanar shader that integrates with URP, usable both as a full material and as
              a triplanar detail layer on top of existing textures—most useful for quick, clean interior props.
            </p>
          </div>
        </div>
        <div class="cs-visual">
          <img src="Assets/triplanar.jpg" alt="Interior scene using triplanar materials">
        </div>
      </div>

      <div class="cs-card">
        <div class="cs-visual">
          <img src="Assets/postfx.jpg" alt="Custom blur and post-processing effects">
        </div>
        <div class="cs-text">
          <div class="cs-eyebrow">TECH 03 · POST</div>
          <h2 class="cs-title">
            Custom Blur & Transitions
            <span class="cs-title-badge">URP</span>
          </h2>
          <div class="cs-meta-line">Dual-Kawase blur · RT-based UI transitions</div>
          <div class="cs-summary">
            <p>
              A set of custom render features for things like dual-Kawase blur, streaks, glitch, and camera
              transitions using render textures—used for item inspection views, menu reveals, and other UI moments.
            </p>
          </div>
        </div>
      </div>

      <div class="cs-card reverse">
        <div class="cs-text">
          <div class="cs-eyebrow">TECH 04 · WORKFLOWS</div>
          <h2 class="cs-title">
            Cloth-Fitting Tools in Blender
            <span class="cs-title-badge">BLENDER</span>
          </h2>
          <div class="cs-meta-line">Iterative fit · complex outfits · rig-aware</div>
          <div class="cs-summary">
            <p>
              A prototype toolchain in Blender to iteratively fit clothing to rigged characters and transfer
              weights, cutting manual setup time for complex outfits down to a few hours per look.
            </p>
          </div>
        </div>
        <div class="cs-visual">
          <img src="Assets/cloth-tool.jpg" alt="Cloth fitting workflow">
        </div>
      </div>
    </section>

    <!-- ============ MY GAMES ============ -->
    <section class="content-section" data-color="140, 100, 255">
      <header class="section-header">
        <div>
          <div class="section-kicker">PERSONAL PROJECTS</div>
          <div class="section-title">My Games</div>
        </div>
        <p class="section-subtitle">
          Where all the pieces meet: rendering, systems, tools, level layout, and how it actually feels to play.
        </p>
      </header>

      <!-- Game 01 -->
      <div class="cs-card">
        <div class="cs-visual">
          <img src="Assets/game-eden-pv.jpg" alt="EDEN game key visual">
        </div>
        <div class="cs-text">
          <div class="cs-eyebrow"><span class="game-tag">GAME 01</span> · PC PROTOTYPE</div>
          <h2 class="cs-title">
            EDEN
            <span class="cs-title-badge">TOP-DOWN SCI-FI</span>
          </h2>
          <div class="cs-meta-line">Combat · exploration · post-collapse fiction</div>
          <div class="cs-summary">
            <p>
              A top-down sci-fi game built around fast fights and quiet in-between spaces. It’s less about
              power fantasy and more about moving through a broken world at your own pace.
            </p>
          </div>
          <div class="cs-details">
            <div class="cs-detail-grid">
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">What I Did</div>
                <ul>
                  <li>Owned the URP rendering setup and custom shaders for the game’s look.</li>
                  <li>Implemented the player controller, combat logic, and camera behavior for combat and exploration.
                  </li>
                  <li>Planned lighting and layout to carry mood and story through space instead of dialogue walls.</li>
                </ul>
              </div>
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">What It Shows</div>
                <ul>
                  <li>How I tie rendering, design, and tools together in a single prototype.</li>
                  <li>That I care a lot about moment-to-moment feel, not just visuals in isolation.</li>
                </ul>
              </div>
            </div>
            <div class="cs-detail-gallery">
              <img src="Assets/eden-1.jpg" alt="EDEN combat frame">
              <img src="Assets/eden-2.jpg" alt="EDEN title or hub scene">
              <img src="Assets/eden-3.jpg" alt="EDEN exploration vista">
            </div>
          </div>
        </div>
      </div>

      <!-- Game 02 -->
      <div class="cs-card reverse">
        <div class="cs-text">
          <div class="cs-eyebrow"><span class="game-tag">GAME 02</span> · PC & MOBILE</div>
          <h2 class="cs-title">
            Last Train to Vladivostok
            <span class="cs-title-badge">DIGITAL BOARD GAME</span>
          </h2>
          <div class="cs-meta-line">Historical setting · systemic play · mobile constraints</div>
          <div class="cs-summary">
            <p>
              A story-driven board game about the Czechoslovak Legion trying to cross a collapsing Russia.
              Designed from the start to run on both desktop and mobile hardware.
            </p>
          </div>
          <div class="cs-details">
            <div class="cs-detail-grid">
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">What I Did</div>
                <ul>
                  <li>Implemented all core game logic, state flow, and UI behavior.</li>
                  <li>Designed and animated UI so it reads cleanly on touch screens and monitors.</li>
                  <li>Tuned performance and memory for low-to-mid range mobile devices.</li>
                </ul>
              </div>
              <div class="cs-detail-block">
                <div class="cs-detail-block-title">What It Shows</div>
                <ul>
                  <li>That I can take a project from prototype to a content-complete, shippable build.</li>
                  <li>That I understand mobile constraints as well as desktop workflows.</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="cs-visual">
          <img src="Assets/game-sys-pv.jpg" alt="Last Train to Vladivostok visual">
        </div>
      </div>
    </section>

    <!-- ============ ABOUT & SKILLS ============ -->
    <section class="content-section">
      <header class="section-header">
        <div>
          <div class="section-kicker">ABOUT & SKILLS</div>
          <div class="section-title">Profile</div>
        </div>
        <p class="section-subtitle">
          A quick look at what I work with day to day: languages, engines, rendering, tools, and design.
        </p>
      </header>

      <div class="about-layout">
        <div class="about-text">
          <p>
            I’m a technical artist and rendering-focused developer graduating in <strong>[Month&nbsp;Year]</strong>.
            Most of my work sits where art direction, engineering, and tooling meet—whether that’s for games,
            interactive spaces, or other real-time pieces.
          </p>
          <p>
            I’m currently looking for roles where I can help build and optimize real-time worlds:
            shaders, lighting, render features, pipelines, and the systems around them.
          </p>
        </div>
        <div class="skills-matrix">
          <div class="skills-group">
            <h3>Programming</h3>
            <p>C#, C++, Python, ShaderLab, GLSL/HLSL, JavaScript &amp; WebGL, SQL</p>
          </div>
          <div class="skills-group">
            <h3>Engines & Pipelines</h3>
            <p>Unity (URP/HDRP, Render Features, Render Graph), UE5, Jobs/Burst, ECS, Addressables, Localization,
              Cinemachine, Input System</p>
          </div>
          <div class="skills-group">
            <h3>Rendering & Tools</h3>
            <p>Stylized shading, optimization, custom render features, custom tools, asset pipeline, Visual Effect Graph
            </p>
          </div>
          <div class="skills-group">
            <h3>Design & Content</h3>
            <p>Narrative & gameplay design, interior layout, lighting & composition, Blender, Maya, cloth-fitting
              workflows</p>
          </div>
        </div>
      </div>
    </section>

    <!-- ============ CONTACT & HORIZON ============ -->
    <section class="content-section">
      <header class="section-header">
        <div>
          <div class="section-kicker">CONTACT</div>
          <div class="section-title">Get in touch</div>
        </div>
        <p class="section-subtitle">
          If any of this looks useful for what you’re building, I’d be happy to talk.
        </p>
      </header>

      <div class="contact-block">
        <ul class="contact-list">
          <li><span class="contact-label">Email</span> <a href="mailto:you@example.com">you@example.com</a></li>
          <li><span class="contact-label">LinkedIn</span> <a href="#">linkedin.com/in/your-profile</a></li>
          <li><span class="contact-label">Resume</span> <a href="#">Download PDF</a></li>
          <li><span class="contact-label">GitHub / ArtStation</span> <a href="#">links here if you want</a></li>
        </ul>
      </div>

      <div class="horizon-wrap">
        <div class="horizon-line">
          <div class="horizon-orbit"></div>
        </div>
        <div class="horizon-caption">END OF PAGE</div>
        <div class="horizon-phrase">
          Looking up is usually where my projects start.
        </div>
      </div>
    </section>

  </main>

  <script>
    // ======= same background & interaction code, slightly compressed comments =======
    const fgCanvas = document.getElementById('render-canvas');
    const fgCtx = fgCanvas.getContext('2d');
    const bgCanvas = document.getElementById('bg-canvas');
    const gl = bgCanvas.getContext('webgl', {
      antialias: true,
      powerPreference: "high-performance",
      alpha: false
    });

    if (!gl) {
      console.error("WebGL not supported.");
      bgCanvas.style.display = 'none';
    }

    let width, height;
    let scrollY = window.scrollY;

    const STAR_COUNT = 40;
    const GRID_SPACING = 120;
    const GRID_DIMENSIONS = 40;
    const GRID_DEPTH_SEGMENTS = GRID_DIMENSIONS / 2;
    const NODE_SIZE = 3.5;

    const stars = [];
    const gridPoints = [];
    const camera = {
      fov: 355,
      y: 0,
      rotationX: 0,
      targetY: 0,
      targetRotationX: 0,
      lerpFactor: 0.07
    };

    function project(p) {
      const cosX = Math.cos(camera.rotationX);
      const sinX = Math.sin(camera.rotationX);
      const translatedY = p.y - camera.y;
      const rotatedY = 41 * translatedY * cosX - 0.1 * p.z * sinX;
      const rotatedZ = 0 * translatedY * sinX + p.z * cosX;
      if (rotatedZ <= 0) return null;
      const scale = camera.fov / rotatedZ;
      return {
        x: width / 2 + p.x * scale,
        y: height / 2 - rotatedY * scale,
        scale,
        z: rotatedZ
      };
    }

    function drawForeground() {
      fgCtx.clearRect(0, 0, width, height);

      fgCtx.fillStyle = '#dce2f0';
      stars.forEach(star => {
        const y = (star.y - scrollY * star.depth + height);
        fgCtx.beginPath();
        fgCtx.arc(star.x, y, star.size, 0, 2 * Math.PI);
        fgCtx.fill();
      });

      const projected = gridPoints.map(project);
      const gridWidth = GRID_DIMENSIONS * 2 + 1;
      fgCtx.strokeStyle = 'rgba(80, 130, 255, 0.2)';
      fgCtx.lineWidth = 1;

      for (let i = 0; i < gridWidth; i++) {
        for (let j = 0; j <= GRID_DEPTH_SEGMENTS; j++) {
          const idx = i * (GRID_DEPTH_SEGMENTS + 1) + j;
          const p = projected[idx];
          if (!p || p.y < 0) continue;
          if (j > 0) {
            const pb = projected[idx - 1];
            if (pb && pb.y > 0) {
              fgCtx.beginPath();
              fgCtx.moveTo(p.x, p.y);
              fgCtx.lineTo(pb.x, pb.y);
              fgCtx.stroke();
            }
          }
          if (i > 0) {
            const ps = projected[idx - (GRID_DEPTH_SEGMENTS + 1)];
            if (ps && ps.y > 0) {
              fgCtx.beginPath();
              fgCtx.moveTo(p.x, p.y);
              fgCtx.lineTo(ps.x, ps.y);
              fgCtx.stroke();
            }
          }
        }
      }

      projected.forEach(p => {
        if (p && p.y > 0) {
          const size = NODE_SIZE * Math.min(p.scale, 1.0);
          const alpha = 1 - Math.min(p.z / 8000, 1);
          if (alpha > 0.01) {
            fgCtx.globalAlpha = alpha;
            fgCtx.shadowBlur = size * 4;
            fgCtx.shadowColor = 'rgba(80, 130, 255, 0.5)';
            fgCtx.fillStyle = 'rgba(80, 130, 255, 0.8)';
            fgCtx.fillRect(p.x - size / 2, p.y - size / 2, size, size);
          }
        }
      });
      fgCtx.globalAlpha = 1;
      fgCtx.shadowBlur = 0;
    }

    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() { gl_Position = vec4(a_position, 0.0, 1.0); }`;

    const fragmentShaderSource = `
      precision highp float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec3 u_color;
      uniform sampler2D u_blueNoise;

      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

      float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                            -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy));
        vec2 x0 = v - i + dot(i, C.xx);
        vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod289(i);
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                        + i.x + vec3(0.0, i1.x, 1.0 ));
        vec3 m = max(0.5 - vec3(
          dot(x0,x0),
          dot(x12.xy,x12.xy),
          dot(x12.zw,x12.zw)
        ), 0.0);
        m = m*m; m = m*m;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 *
             ( a0*a0 + h*h );
        vec3 g;
        g.x  = a0.x  * x0.x  + h.x  * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }

      float fbm(vec2 st) {
        st *= 0.1; st += 0.1;
        float value = 0.0;
        float amplitude = 0.5;
        for (int i = 0; i < 6; i++) {
          value += amplitude * snoise(st);
          st *= 2.0;
          amplitude *= 0.5;
        }
        return value;
      }

      void main() {
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        st.x *= u_resolution.x / u_resolution.y;
        float t = u_time * 0.6;
        vec2 q = vec2(
          fbm(st + vec2(t*0.2, t*0.1)),
          fbm(st + vec2(-t*0.15, t*0.25))
        );
        vec2 r = vec2(
          fbm(st + q*2.0 + vec2(t*-0.3, t*0.05)),
          fbm(st + q*2.0 + vec2(t*0.1, -t*0.3))
        );
        float value = fbm(st + r*0.5);
        float contrastValue = pow(max(0.0, value), 2.2);
        vec3 finalColor = u_color * contrastValue * 1.5;
        vec3 noise = texture2D(u_blueNoise, gl_FragCoord.xy / 256.0).rgb;
        finalColor += (noise - 0.5) / 128.0;
        gl_FragColor = vec4(clamp(finalColor, 0.0, 1.0), 1.0);
      }`;

    let glProgram,
      positionAttributeLocation,
      resolutionUniformLocation,
      timeUniformLocation,
      colorUniformLocation,
      blueNoiseUniformLocation;
    let currentR = 50, currentG = 80, currentB = 220;
    let targetR = 50, targetG = 80, targetB = 220;
    let blueNoiseTexture;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error("Shader compile error:", gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, v, f) {
      const program = gl.createProgram();
      gl.attachShader(program, v);
      gl.attachShader(program, f);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link error:", gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    function loadTexture(gl, url) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.RGBA,
        1, 1, 0,
        gl.RGBA, gl.UNSIGNED_BYTE,
        new Uint8Array([0, 0, 0, 255])
      );
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
          gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      };
      image.src = 'assets/blueNoise.png';
      return texture;
    }

    function setupWebGL() {
      if (!gl) return;
      const vs = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      glProgram = createProgram(gl, vs, fs);
      gl.useProgram(glProgram);

      positionAttributeLocation = gl.getAttribLocation(glProgram, "a_position");
      resolutionUniformLocation = gl.getUniformLocation(glProgram, "u_resolution");
      timeUniformLocation = gl.getUniformLocation(glProgram, "u_time");
      colorUniformLocation = gl.getUniformLocation(glProgram, "u_color");
      blueNoiseUniformLocation = gl.getUniformLocation(glProgram, "u_blueNoise");

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1, -1, 1, -1, -1, 1,
          -1, 1, 1, -1, 1, 1
        ]),
        gl.STATIC_DRAW
      );

      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

      blueNoiseTexture = loadTexture(gl, 'assets/blueNoise.png');
    }

    function renderBackground(time) {
      if (!gl) return;
      time *= 0.001;

      currentR += (targetR - currentR) * 0.02;
      currentG += (targetG - currentG) * 0.02;
      currentB += (targetB - currentB) * 0.02;

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
      gl.uniform1f(timeUniformLocation, time);
      gl.uniform3f(
        colorUniformLocation,
        currentR / 255, currentG / 255, currentB / 255
      );
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, blueNoiseTexture);
      gl.uniform1i(blueNoiseUniformLocation, 0);

      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function masterInit() {
      width = window.innerWidth;
      height = window.innerHeight;

      fgCanvas.width = width;
      fgCanvas.height = height;
      if (gl) {
        bgCanvas.width = width;
        bgCanvas.height = height;
      }

      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: (0.15 + 0.7 * Math.random()) * width,
          y: (Math.random() - 0.9) * height,
          depth: Math.random() * 0.4 + 0.1,
          size: Math.random() * 1.2 + 0.5
        });
      }

      gridPoints.length = 0;
      for (let i = -GRID_DIMENSIONS; i <= GRID_DIMENSIONS; i++) {
        for (let j = 0; j <= GRID_DEPTH_SEGMENTS; j++) {
          gridPoints.push({
            x: i * GRID_SPACING,
            y: 0,
            z: j * 1.5 * GRID_SPACING
          });
        }
      }
    }

    function masterAnimate(time) {
      scrollY = window.scrollY;
      const scrollHeight = document.body.scrollHeight - window.innerHeight;
      const scrollRatio = scrollHeight > 0 ? scrollY / scrollHeight : 0;

      const targetY = 1200 * (0 + 0.01 * (1 - scrollRatio));
      const targetRotationX = (0.5 * (-6 + 6 * scrollRatio)) * Math.PI / 180 + 1.45;

      camera.y += (targetY - camera.y) * camera.lerpFactor;
      camera.rotationX += (targetRotationX - camera.rotationX) * camera.lerpFactor;

      if (gl) renderBackground(time);
      drawForeground();

      requestAnimationFrame(masterAnimate);
    }

    const sections = document.querySelectorAll('.content-section[data-color]');
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const [r, g, b] = entry.target.dataset.color.split(',').map(Number);
          targetR = r;
          targetG = g;
          targetB = b;
        }
      });
    }, { threshold: 0.5 });

    sections.forEach(section => observer.observe(section));

    document.querySelectorAll('.cs-text').forEach(textBlock => {
      textBlock.addEventListener('click', () => {
        const card = textBlock.closest('.cs-card');
        if (!card) return;
        card.classList.toggle('is-expanded');
      });
    });

    window.addEventListener('resize', () => {
      masterInit();
      if (gl) gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    });

    setupWebGL();
    masterInit();
    requestAnimationFrame(masterAnimate);
  </script>
</body>

</html>